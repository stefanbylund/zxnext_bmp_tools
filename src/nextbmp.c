/*******************************************************************************
 * Stefan Bylund 2017
 *
 * Program for converting the palette in an uncompressed 8-bit BMP file to ZX
 * Spectrum Next format. The original RGB888 colors in the palette are converted
 * to RGB333 colors and then back to their equivalent RGB888 colors. If no
 * destination BMP file is specified, the source BMP file is modified.
 * This program is suitable for converting BMP files for layer 2 graphics
 * (256 x 192, 320 x 256 and 640 x 256) and sprite sheets (4-bit and 8-bit).
 *
 * Note that when the original RGB888 colors in the palette are converted to
 * RGB333 colors, the resulting 3-bit color components may not end up as
 * integers and must be rounded to an integer (0 - 7). By default, the 3-bit
 * color components are rounded to the nearest integer (-round). However,
 * depending on the original RGB888 colors, this may not always be the best
 * choice. Sometimes, better results are achieved by rounding upwards (-ceil)
 * or downwards (-floor).
 *
 * If the -min-palette option is specified, the converted palette is minimized
 * by removing any duplicated colors, sorting it in ascending order (i.e. the
 * same order as in the Spectrum Next standard palette), and clearing any unused
 * palette entries at the end. This is useful if you convert images that you
 * have not created the palette for and which may end up having duplicated
 * palette colors when being converted. This option is ignored if the
 * -std-palette option is given.
 *
 * If the -std-palette option is specified, the original RGB888 colors in the
 * palette are converted to the Spectrum Next standard palette RGB332 colors
 * (which are extended to RGB333 colors when displayed). This is useful if you
 * need to use the standard palette. However, better results are generally
 * achieved when converting to the closest matching RGB333 colors. This option
 * is ignored if the -4bit option is given.
 *
 * If the -4bit option is specified, the first 16 unique colors in the palette
 * will be moved to the start of the palette and all other palette entries
 * will be cleared. Any pixels in the image referencing any of the discarded
 * colors will also be cleared. The result will be a 4-bit image saved as an
 * 8-bit BMP file. Use this option for images intended to be displayed in the
 * 640 x 256 layer 2 mode or for 4-bit sprite sheets.
 *
 * Note: The BMP file format supports both 4 and 8 bits per pixel. However, most
 * modern paint programs only support 8 bits per pixel as the lowest color depth
 * when saving to a BMP file. Therefore, nextbmp assumes that a 16 color 4-bit
 * image is contained in an 8-bit BMP file and not a 4-bit BMP file. If you would
 * have an actual 4-bit BMP file, you must first save it as an 8-bit BMP file in
 * your paint program before using it with the nextbmp tool and its -4bit option.
 *
 * Note: Use the nextraw companion tool to convert the BMP file generated by
 * nextbmp to a raw image file for Spectrum Next.
 *
 * This program is inspired by Jim Bagley's BMPtoNext tool but with added
 * support for the Spectrum Next RGB333 palette and with more options and
 * validations.
 ******************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define FILE_HEADER_SIZE 14
#define MIN_DIB_HEADER_SIZE 40
#define HEADER_SIZE 54
#define MIN_BMP_FILE_SIZE 1082
#define PALETTE_SIZE 1024
#define NUM_PALETTE_COLORS 256

typedef enum rounding_mode
{
    FLOOR,
    CEIL,
    ROUND
} rounding_mode_t;

typedef struct arguments
{
    rounding_mode_t rounding_mode;
    bool minimize_palette;
    bool use_std_palette;
    bool use_4bit;
    char *in_filename;
    char *out_filename;
} arguments_t;

static uint8_t header[HEADER_SIZE];

static uint8_t palette[PALETTE_SIZE];

static uint8_t min_palette[PALETTE_SIZE];

static uint8_t min_palette_index[NUM_PALETTE_COLORS];

static uint8_t std_palette_index[NUM_PALETTE_COLORS];

static uint8_t *image;

static void print_usage(void)
{
    printf("Usage: nextbmp [-floor|-ceil|-round] [-min-palette] [-std-palette] [-4bit] <srcfile.bmp> [<dstfile.bmp>]\n");
    printf("Convert the palette in an uncompressed 8-bit BMP file to ZX Spectrum Next format.\n");
    printf("If no destination BMP file is specified, the source BMP file is modified.\n");
    printf("\n");
    printf("Options:\n");
    printf("  -floor        Round down the color values to the nearest integer.\n");
    printf("  -ceil         Round up the color values to the nearest integer.\n");
    printf("  -round        Round the color values to the nearest integer (default).\n");
    printf("  -min-palette  If specified, minimize the palette by removing any duplicated colors, sort\n");
    printf("                it in ascending order, and clear any unused palette entries at the end.\n");
    printf("                This option is ignored if the -std-palette option is given.\n");
    printf("  -std-palette  If specified, convert to the Spectrum Next standard palette colors.\n");
    printf("                This option is ignored if the -4bit option is given.\n");
    printf("  -4bit         If specified, use 4 bits per pixel (16 colors). Default is 8 bits per pixel (256 colors).\n");
}

static bool parse_args(int argc, char *argv[], arguments_t *args)
{
    if (argc == 1)
    {
        print_usage();
        return false;
    }

    for (int i = 1; i < argc; i++)
    {
        if (argv[i][0] == '-')
        {
            if (!strcmp(argv[i], "-floor"))
            {
                args->rounding_mode = FLOOR;
            }
            else if (!strcmp(argv[i], "-ceil"))
            {
                args->rounding_mode = CEIL;
            }
            else if (!strcmp(argv[i], "-round"))
            {
                args->rounding_mode = ROUND;
            }
            else if (!strcmp(argv[i], "-min-palette"))
            {
                args->minimize_palette = true;
            }
            else if (!strcmp(argv[i], "-std-palette"))
            {
                args->use_std_palette = true;
            }
            else if (!strcmp(argv[i], "-4bit"))
            {
                args->use_4bit = true;
            }
            else if (!strcmp(argv[i], "-help"))
            {
                print_usage();
                return false;
            }
            else
            {
                fprintf(stderr, "Invalid option: %s\n", argv[i]);
                print_usage();
                return false;
            }
        }
        else
        {
            if (args->in_filename == NULL)
            {
                args->in_filename = argv[i];
            }
            else if (args->out_filename == NULL)
            {
                args->out_filename = argv[i];
            }
            else
            {
                fprintf(stderr, "Too many arguments.\n");
                print_usage();
                return false;
            }
        }
    }

    if (args->in_filename == NULL)
    {
        fprintf(stderr, "Input file not specified.\n");
        print_usage();
        return false;
    }
    if (args->out_filename == NULL)
    {
        args->out_filename = args->in_filename;
    }

    return true;
}

static void exit_with_msg(const char *format, ...)
{
  va_list args;
  va_start(args, format);
  vfprintf(stderr, format, args);
  va_end(args);

  exit(EXIT_FAILURE);
}

static bool is_valid_bmp_file(uint32_t *palette_offset,
                              uint32_t *image_offset,
                              uint32_t *image_width,
                              int32_t *image_height)
{
    if ((header[0] != 'B') || (header[1] != 'M'))
    {
        fprintf(stderr, "Not a BMP file.\n");
        return false;
    }

    uint32_t file_size = *((uint32_t *) (header + 2));
    if (file_size < MIN_BMP_FILE_SIZE)
    {
        fprintf(stderr, "Invalid size of BMP file.\n");
        return false;
    }

    *image_offset = *((uint32_t *) (header + 10));
    if (*image_offset >= file_size)
    {
        fprintf(stderr, "Invalid header of BMP file.\n");
        return false;
    }

    uint32_t dib_header_size = *((uint32_t *) (header + 14));
    if (dib_header_size < MIN_DIB_HEADER_SIZE)
    {
        // At least a BITMAPINFOHEADER is required.
        fprintf(stderr, "Invalid/unsupported header of BMP file.\n");
        return false;
    }

    *palette_offset = FILE_HEADER_SIZE + dib_header_size;

    *image_width = *((uint32_t *) (header + 18));
    if (*image_width == 0)
    {
        fprintf(stderr, "Invalid image width in BMP file.\n");
        return false;
    }

    *image_height = *((int32_t *) (header + 22));
    if (*image_height == 0)
    {
        fprintf(stderr, "Invalid image height in BMP file.\n");
        return false;
    }

    if (*image_width * abs(*image_height) >= file_size)
    {
        fprintf(stderr, "Invalid image size in BMP file.\n");
        return false;
    }

    uint16_t bpp = *((uint16_t *) (header + 28));
    if (bpp != 8)
    {
        fprintf(stderr, "Not an 8-bit BMP file.\n");
        return false;
    }

    uint32_t compression = *((uint32_t *) (header + 30));
    if (compression != 0)
    {
        fprintf(stderr, "Not an uncompressed BMP file.\n");
        return false;
    }

    return true;
}

static void free_image(void)
{
    if (image != NULL)
    {
        free(image);
        image = NULL;
    }
}

static uint8_t c8_to_c3(uint8_t c8, rounding_mode_t rounding_mode)
{
    double c3 = (c8 * 7.0) / 255.0;

    switch (rounding_mode)
    {
        case FLOOR:
            return (uint8_t) floor(c3);
        case CEIL:
            return (uint8_t) ceil(c3);
        case ROUND:
            // Fall through
        default:
            return (uint8_t) round(c3);
    }
}

static uint8_t c8_to_c2(uint8_t c8, rounding_mode_t rounding_mode)
{
    double c2 = (c8 * 3.0) / 255.0;

    switch (rounding_mode)
    {
        case FLOOR:
            return (uint8_t) floor(c2);
        case CEIL:
            return (uint8_t) ceil(c2);
        case ROUND:
            // Fall through
        default:
            return (uint8_t) round(c2);
    }
}

static uint8_t c2_to_c3(uint8_t c2)
{
    return (c2 << 1) | (((c2 >> 1) | c2) & 0x01);
}

static uint8_t c3_to_c8(uint8_t c3)
{
    return (uint8_t) round((c3 * 255.0) / 7.0);
}

static void convert_palette(rounding_mode_t rounding_mode)
{
    // Update the colors in the palette.
    // The original RGB888 colors in the palette are converted to
    // RGB333 colors and then back to their equivalent RGB888 colors.
    for (int i = 0; i < NUM_PALETTE_COLORS; i++)
    {
        // BMP palette contains BGRA colors.
        uint8_t r8 = palette[i * 4 + 2];
        uint8_t g8 = palette[i * 4 + 1];
        uint8_t b8 = palette[i * 4 + 0];

        uint8_t r3 = c8_to_c3(r8, rounding_mode);
        uint8_t g3 = c8_to_c3(g8, rounding_mode);
        uint8_t b3 = c8_to_c3(b8, rounding_mode);

        r8 = c3_to_c8(r3);
        g8 = c3_to_c8(g3);
        b8 = c3_to_c8(b3);

        palette[i * 4 + 3] = 0;
        palette[i * 4 + 2] = r8;
        palette[i * 4 + 1] = g8;
        palette[i * 4 + 0] = b8;
    }
}

static void convert_standard_palette(rounding_mode_t rounding_mode)
{
    // Update the colors in the palette.
    // The original RGB888 colors in the palette are converted to the RGB332/
    // RGB333 colors in the standard palette and then back to their equivalent
    // RGB888 colors.
    for (int i = 0; i < NUM_PALETTE_COLORS; i++)
    {
        // BMP palette contains BGRA colors.
        uint8_t r8 = palette[i * 4 + 2];
        uint8_t g8 = palette[i * 4 + 1];
        uint8_t b8 = palette[i * 4 + 0];

        // Convert the RGB888 color to an RGB332 color.
        // The RGB332 value is also the index for this color in the standard
        // palette. The pixels having palette index i will be updated with this
        // new palette index which points to the new location of the converted
        // RGB888 color that was originally stored at index i.
        uint8_t r3 = c8_to_c3(r8, rounding_mode);
        uint8_t g3 = c8_to_c3(g8, rounding_mode);
        uint8_t b2 = c8_to_c2(b8, rounding_mode);
        std_palette_index[i] = (r3 << 5) | (g3 << 2) | (b2 << 0);

        // Create the standard RGB332/RGB333 color for this palette index.
        // The standard RGB332 color has the same value as its index in the
        // standard palette. The actual color displayed on the Spectrum Next
        // is an RGB333 color where the lowest blue bit as a bitwise OR between
        // the two blue bits in the RGB332 color.
        uint8_t std_r3 = (uint8_t) ((i >> 5) & 0x07);
        uint8_t std_g3 = (uint8_t) ((i >> 2) & 0x07);
        uint8_t std_b2 = (uint8_t) ((i >> 0) & 0x03);
        uint8_t std_b3 = c2_to_c3(std_b2);

        // Convert the standard RGB333 color back to an RGB888 color.
        r8 = c3_to_c8(std_r3);
        g8 = c3_to_c8(std_g3);
        b8 = c3_to_c8(std_b3);

        // Update the palette with the RGB888 representation of the standard RGB333 color.
        palette[i * 4 + 3] = 0;
        palette[i * 4 + 2] = r8;
        palette[i * 4 + 1] = g8;
        palette[i * 4 + 0] = b8;
    }
}

static int compare_color(const void *p1, const void *p2)
{
    uint8_t *color1 = (uint8_t *) p1;
    uint8_t *color2 = (uint8_t *) p2;

    uint8_t r1 = color1[2];
    uint8_t g1 = color1[1];
    uint8_t b1 = color1[0];

    uint8_t r2 = color2[2];
    uint8_t g2 = color2[1];
    uint8_t b2 = color2[0];

    uint32_t rgb1 = (r1 << 16) | (g1 << 8) | (b1 << 0);
    uint32_t rgb2 = (r2 << 16) | (g2 << 8) | (b2 << 0);

    return (rgb1 > rgb2) ? 1 : (rgb1 < rgb2) ? -1 : 0;
}

static int create_minimized_palette(void)
{
    uint32_t *min_palette_colors = (uint32_t *) min_palette;
    int last_unique_color_index = 0;

    memcpy(min_palette, palette, sizeof(palette));

    // Sort the palette colors in ascending RGB order.
    qsort(min_palette, NUM_PALETTE_COLORS, sizeof(uint32_t), compare_color);

    // Remove any duplicated palette colors.
    for (int i = 0; i < NUM_PALETTE_COLORS; i++)
    {
        if (min_palette_colors[i] != min_palette_colors[last_unique_color_index])
        {
            min_palette_colors[++last_unique_color_index] = min_palette_colors[i];
        }
    }

    // Set any unused palette entries to 0 (black).
    for (int i = last_unique_color_index + 1; i < NUM_PALETTE_COLORS; i++)
    {
        min_palette_colors[i] = 0;
    }

    // Return number of unique palette colors.
    return last_unique_color_index + 1;
}

static void create_minimized_palette_index_table(void)
{
    uint32_t *palette_colors = (uint32_t *) palette;
    uint32_t *min_palette_colors = (uint32_t *) min_palette;

    /*
     * Iterate over the originally converted palette and for each color, look up
     * its new index in the minimized palette and write that index in the index
     * table at the same position as the color in the originally converted
     * palette. This index table will be used to update the pixels in the image
     * to use the minimized palette.
     */

    for (int i = 0; i < NUM_PALETTE_COLORS; i++)
    {
        for (int j = 0; j < NUM_PALETTE_COLORS; j++)
        {
            if (palette_colors[i] == min_palette_colors[j])
            {
                min_palette_index[i] = j;
                break;
            }
        }
    }
}

static void shrink_to_4bit_palette(void)
{
    uint32_t *palette_colors = (uint32_t *) palette;

    // Set palette entries 16 to 255 to color 0 (black).
    for (int i = 16; i < NUM_PALETTE_COLORS; i++)
    {
        palette_colors[i] = 0;
    }
}

static bool copy_file(FILE *src_file, FILE *dst_file)
{
    uint8_t buffer[BUFSIZ];
    size_t num_read;

    while ((num_read = fread(buffer, sizeof(uint8_t), sizeof(buffer), src_file)) > 0)
    {
        if (fwrite(buffer, sizeof(uint8_t), num_read, dst_file) != num_read)
        {
            return false;
        }
    }

    return true;
}

int main(int argc, char *argv[])
{
    arguments_t args = {ROUND, false, false, false, NULL, NULL};
    bool create_new_file;
    bool update_image_data;
    uint32_t palette_offset;
    uint32_t image_offset;
    uint32_t image_width;
    int32_t image_height;

    // Parse program arguments.
    if (!parse_args(argc, argv, &args))
    {
        exit(EXIT_FAILURE);
    }
    create_new_file = (args.out_filename != NULL) && strcmp(args.in_filename, args.out_filename);
    update_image_data = args.minimize_palette || args.use_std_palette || args.use_4bit;

    // Open the BMP file and validate its header.
    FILE *in_file = fopen(args.in_filename, "rb");
    if (in_file == NULL)
    {
        exit_with_msg("Can't open file %s.\n", args.in_filename);
    }
    if (fread(header, sizeof(uint8_t), sizeof(header), in_file) != sizeof(header))
    {
        exit_with_msg("Can't read the BMP header in file %s.\n", args.in_filename);
    }
    if (!is_valid_bmp_file(&palette_offset, &image_offset, &image_width, &image_height))
    {
        exit_with_msg("The file %s is not a valid or supported BMP file.\n", args.in_filename);
    }

    // Calculate image size.
    // Note: Image width is padded to a multiple of 4 bytes.
    uint32_t padded_image_width = (image_width + 3) & ~0x03;
    image_height = abs(image_height);
    uint32_t image_size = padded_image_width * image_height;

    // Allocate memory for image data.
    if (update_image_data)
    {
        image = malloc(image_size);
        if (image == NULL)
        {
            exit_with_msg("Can't allocate memory for image data.\n");
        }
        atexit(free_image);
    }

    // Read the palette and image data.
    if (fseek(in_file, palette_offset, SEEK_SET) != 0)
    {
        exit_with_msg("Can't access the BMP palette in file %s.\n", args.in_filename);
    }
    if (fread(palette, sizeof(uint8_t), sizeof(palette), in_file) != sizeof(palette))
    {
        exit_with_msg("Can't read the BMP palette in file %s.\n", args.in_filename);
    }
    if (update_image_data)
    {
        if (fseek(in_file, image_offset, SEEK_SET) != 0)
        {
            exit_with_msg("Can't access the BMP image data in file %s.\n", args.in_filename);
        }
        if (fread(image, sizeof(uint8_t), image_size, in_file) != image_size)
        {
            exit_with_msg("Can't read the BMP image data in file %s.\n", args.in_filename);
        }
    }
    fclose(in_file);

    // Update the colors in the palette.
    if (args.use_std_palette && !args.use_4bit)
    {
        // Convert the colors in the palette to the Spectrum Next standard palette RGB332 colors.
        convert_standard_palette(args.rounding_mode);

        // Update the image pixels to use the new palette indexes of the standard palette colors.
        for (int i = 0; i < image_size; i++)
        {
            image[i] = std_palette_index[image[i]];
        }
    }
    else
    {
        // Convert the colors in the palette to the closest matching RGB333 colors.
        convert_palette(args.rounding_mode);

        if (args.minimize_palette || args.use_4bit)
        {
            // Minimize the converted palette by removing any duplicated colors and sort it
            // in ascending RGB order. Any unused palette entries at the end are set to 0 (black).
            int num_unique_colors = create_minimized_palette();
            printf("The minimized palette contains %d unique colors.\n", num_unique_colors);

            // Create an index table containing the palette indexes of the minimized palette
            // that correspond to the palette indexes of the originally converted palette.
            create_minimized_palette_index_table();

            // Copy back the minimized palette to the original palette.
            memcpy(palette, min_palette, sizeof(min_palette));

            // Update the image pixels to use the palette indexes of the minimized palette.
            for (int i = 0; i < image_size; i++)
            {
                image[i] = min_palette_index[image[i]];
            }

            // Handle 4-bit case.
            if (args.use_4bit && num_unique_colors > 16)
            {
                printf("Warning: The palette contains more than 16 unique colors, %d colors will be discarded.\n",
                       num_unique_colors - 16);

                // Shrink the palette to 16 colors.
                shrink_to_4bit_palette();

                // Remove references to discarded colors in image.
                for (int i = 0; i < image_size; i++)
                {
                    if (image[i] > 15)
                    {
                        image[i] = 0;
                    }
                }
            }
        }
    }

    // Write the updated palette and image data. Update the original BMP file or a copy of it.
    FILE *out_file = fopen(args.out_filename, create_new_file ? "wb" : "r+b");
    if (out_file == NULL)
    {
        exit_with_msg("Can't open file %s.\n", args.out_filename);
    }
    if (create_new_file)
    {
        in_file = fopen(args.in_filename, "rb");
        if (in_file == NULL)
        {
            exit_with_msg("Can't open file %s.\n", args.in_filename);
        }
        if (!copy_file(in_file, out_file))
        {
            exit_with_msg("Can't copy file %s to %s.\n", args.in_filename, args.out_filename);
        }
        fclose(in_file);
    }
    if (fseek(out_file, palette_offset, SEEK_SET) != 0)
    {
        exit_with_msg("Can't access the BMP palette in file %s.\n", args.out_filename);
    }
    if (fwrite(palette, sizeof(uint8_t), sizeof(palette), out_file) != sizeof(palette))
    {
        exit_with_msg("Can't write the BMP palette in file %s.\n", args.out_filename);
    }
    if (update_image_data)
    {
        if (fseek(out_file, image_offset, SEEK_SET) != 0)
        {
            exit_with_msg("Can't access the BMP image data in file %s.\n", args.out_filename);
        }
        if (fwrite(image, sizeof(uint8_t), image_size, out_file) != image_size)
        {
            exit_with_msg("Can't write the BMP image data in file %s.\n", args.out_filename);
        }
    }
    fclose(out_file);

    return 0;
}
